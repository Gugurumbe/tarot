/**
   @page tutoriel Tutoriel : utilisation, contribution

   @section zero À partir de zéro

   Vous voulez développer votre propre client (ou votre propre
   serveur). Vous devez vous connecter en tcp sur le serveur (45678,
   port par défaut). Des messages seront échangés avec lui. Un message
   contient :

   1. Sa taille, sur 1 octet non signé.
   2. Son type, sur 1 octet non signé.
   3. Sa partie variable.
   
   Voici les types :

   - 0  : erreur_protocole. Pas de partie variable. Signification :
   vous avez dit quelque chose à un moment inopportun, ou ça n'entre
   pas dans le protocole.

   - 1  : refuse. Pas de partie variable. Signification : vous avez
   fait une requête du bon type au bon moment, mais elle ne respecte
   pas les règles. Valable aussi si le nom que vous souhaitez utiliser
   est déjà pris.

   - 2  : numero. Morceau variable : mon numéro sur 1 octet non
   signé. Votre numéro est un nombre entre 0 et 4 inclus. Si c'est 0,
   vous devez être le premier à priser. Si c'est x, il faut attendre
   de recevoir x messages de type contrat avant de priser.

   - 3  : distribution. Morceau variable : mes 15 cartes, chacune sur 1
   octet non signé. 

   - 4  : prise. Morceau variable : ma prise (1 octet, non signé). 0 :
   passe, 4 : garde contre. Le client doit émettre ce message. 

   - 5  : contrat. Morceau variable : la prise du joueur (1 octet, non
   signé). Un contrat intermédiaire a été formulé.

   - 6  : appel. Pas de partie variable. Vous avez remporté les
   enchères, et vous devez maintenant appeler une carte.

   - 7  : appeler. Morceau variable : la carte que vous voulez appeler
   (1 octet, non signé).

   - 8  : contrat_final. Morceau variable : 1 octet non signé
   (preneur), 1 octet non signé (prise), 1 octet non signé (carte
   appelée). 

   - 9  : chien. Morceau variable : 3 octets (les 3 cartes dévoilées du
   chien). Si vous êtes le preneur, vous devez écarter.

   - 10 : ecart. Morceau variable : 3 octets (les 3 cartes que vous
   voudriez écarter).

   - 11 : atout. Morceau variable : au plus 3 octets (les atouts
   écartés). 

   - 12 : inutilisé

   - 13 : jeu. Morceau variable : 1 octet, le joueur devant
     ouvrir. Pour l'instant, c'est 0.

   - 14 : inutilisé

   - 15 : inutilisé

   - 16 : requete. Morceau variable : 1 octet (la carte que vous
   voudriez jouer). C'est à vous s'il y a eu (votre tour - tour du
   joueur d'ouverture) modulo 5 cartes jouées depuis le dernier pli.

   - 17 : carte. Morceau variable : 1 octet (la carte jouée). À vous de
   déterminer qui l'a jouée, à partir du numéro du joueur d'ouverture
   et le nombre de cartes jouées depuis la fin du dernier pli.

   - 18 : pli. Morceau variable : 1 octet (numéro du joueur
   d'ouverture). 

   - 19 : resultat. La donne est finie. Morceau variable : 5 mots de 2
   octets, signés (les résultats de chacun depuis le dernier
   changement de siège).
   
   - 20 : identification. Vous devez donner un nom.

   - 21 : identifier. Vous tentez de vous donner un nom. Morceau
   variable : 16 octets pour votre nom (utf-8). Attention : si le nom
   est déjà pris, vous recevez un "refuse", mais le serveur s'en
   souvient pour dire aux autres que quelqu'un d'autre voulait se
   connecter avec ce nom. Vous avez droit à 3 essais, puis c'est la
   déconnexion. Dans ce cas, personne ne reçoit aucun message. Si
   c'est réussi, vous recevez "connexion".

   - 22 : connexion. Un nouveau joueur vient de se connecter. Morceau
   variable : 3 * 16 octets, les 3 noms successifs qu'il a
   essayés. S'il n'en a essayé que 1 ou 2, le dernier est répété.

   - 23 : invitation. Une table vous a invité. Morceau variable : le
   nom de la table, sur 16 octets. Peut arriver à n'importe quel
   moment.

   - 24 : deconnexion. Un joueur s'est déconnecté. Morceau variable :
   16 octets, le nom du joueur.

   - 25 : rejoindre. Vous voulez rejoindre une table. Morceau variable
   : 16 octets, le nom de la table. Accepté lorsque l'on reçoit
   "accueilli". 

   - 26 : accueilli. Vous faites partie de cette table jusqu'à votre
   déconnexion. Vous ne recevez plus d'invitations et toutes les
   invitations à votre nom sont annulées. Morceau variable : 16 octets
   pour le nom du joueur, 16 octets pour le nom de la table.

   - 27 : joueur. Un nouveau joueur vient rejoindre votre partie. 1
   octet : son numéro, 16 octets : son nom. Survient à chaque nouvelle
   donne, avec le numéro adapté pour que le 0 commence
   toujours. Enchaîne avec numero, distribution et le jeu.

   - 28 : accueillir. Vous voulez accueillir une nouvelle
   table. Morceau variable : 16 octets, le nom de votre table.

   - 29 : table. Une nouvelle table a été ouverte. Morceau variable :
   16 octets, le nom de la table.

   - 30 : inviter. En tant que chef de table, vous changez
   l'invitation pour un siège. Morceau variable : 1 octet pour le
   numéro, 1 octet qui vaut 0 (personne), 1 (tout le monde) ou 2 (un
   nom en particulier, auquel cas 16 octets suivent pour le nom de la
   personne). Arrête la partie si elle est en cours. Refusé si on
   reçoit "refuse". Accepté si on reçoit "siege", peut être refusé si
   la partie n'est pas stoppée, ou si le joueur existe et est en
   jeu. Si le joueur n'existe pas, l'invitation lui sera envoyée à sa
   connexion. Si le joueur existe, elle lui est envoyée
   immédiatement. Le joueur qui perd son siège est déconnecté, sauf
   s'il s'agit du chef. Auquel cas il doit y avoir au moins un siège
   qui n'accueille personne, sans quoi la transaction est
   refusée. Pour changer votre numéro, vous devez donc : inviter
   personne sur votre nouveau numéro, inviter le nom de celui que vous
   venez de renvoyer sur votre ancien numéro, vous inviter sur votre
   nouveau numéro. Si les 5 joueurs sont présents, chacun reçoit
   officiellement son numéro, puis ses cartes. La partie commence.

   - 31 : siege. Un nouveau siège a été attribué. Même partie variable
   que "inviter".

   - 32 : stopper. Sans partie variable, le chef demande de stopper la
     partie.

   - 33 : stop. Pas de partie variable. La levée est annulée, on peut
   changer les sièges. Survient si un joueur se déconnecte pendant la
   partie, ou si le chef demande "stopper".
   .

   Vous devez donc émettre : prise, appeler, ecarter, requete,
   requete, ... dans le cas où vous prenez (prise autre que garde
   contre ou garde sans) en tant que client. Hors jeu, vous devez
   émettre rejoindre ou accueillir, et dans ce cas gérer votre table.
   
   @section un En utilisant ce qu'on a déjà
   
   L'objectif est d'utiliser la classe ClientJeu, qui fournit de
   l'information sous forme de signaux Qt, et qui permet d'enregistrer
   des ordres facilement. Vous avez droit à tous les signaux de
   ClientJeu, plus ClientJeu::partie qui vous fournit une
   PartieClient, d'où vous pourrez savoir le Partie::tour(), 
   Partie::attaquant(), PartieClient::mon_jeu(), Partie::tapis(),
   ... 
   
   En ce qui concerne les ordres à envoyer, vous pouvez utiliser
   ClientJeu::formuler_prise, ClientJeu::formuler_appel,
   ClientJeu::formuler_ecart, ClientJeu::formuler_requete.

   Étape par étape :
   
   Commencez par récupérer les sources, puis déplacez-vous dans
   client/. Faites un dossier, par exemple ai, puis
   déplacez-vous dedans et faites un nouveau projet Qt. Le fichier de
   projet doit ressembler au fichier ci-dessous : on ajoute la dépendance 
   network, et on inclue et compile tous les fichiers de ../shared et
   ../../shared. 
   
   @include ../client/ai/ia.pro

   Maintenant, on peut travailler. Faites un fichier principal (ici,
   main_program.cpp), ici :

   @include ../client/ai/main_program.cpp

   On voit que l'on a fait une classe externe, IA. Il suffit après de
   connecter les signaux d'information de ClientJeu aux slots de notre
   nouvelle classe. Ensuite, il faut appeler les slots
   ClientJeu::formuler_* pour interagir avec le serveur. Dans
   l'exemple, j'ai fait une IA dite "basique" :

   @include ../client/ai/ia.hpp
   
   @include ../client/ai/ia.cpp

   @subsection emission Ordre d'émission des signaux
   Les signaux sont émis dans un ordre "logique" dans les différentes
   situations.

   Phase d'enchères :
   1. ClientJeu::contrat_intermediaire() (du joueur précédent)
   2. ClientJeu::doit_priser() (Vous devez priser à partir de ce moment)
   3. ClientJeu::enchere_acceptee() (ou ClientJeu::enchere_refusee()
   et retour à 2.)
   4. ClientJeu::contrat_intermediaire() (le vôtre)
   5. ClientJeu::contrat_intermediaire() celui du joueur suivant.
   
   Appels :
   1. ClientJeu::contrat_intermediaire() (du joueur précédent)
   2. ClientJeu::doit_appeler() (vous devez appeler à partir de ce
   moment)
   3. ClientJeu::appel_accepte() (ou ClientJeu::appel_refuse() et
   retour à 2.)
   4. ClientJeu::contrat_final()
   5. ClientJeu::chien() (ou saut à la phase de jeu en cas de contrat
   supérieur) 
   6. ClientJeu::jeu_change()
   7. ClientJeu::doit_ecarter() (vous devez écarter à partir de ce
   moment)
   8. ClientJeu::atout_au_chien() (éventuellement)
   9. ClientJeu::ecart_accepte() (ou ClientJeu::ecart_refuse() et
   retour à 7.)
   10. ClientJeu::jeu_change()

   Jeu :
   1. ClientJeu::carte_jouee() (par le joueur précédent)
   2. ClientJeu::maitre_change() (éventuellement)
   3. ClientJeu::tapis_change()
   4. ClientJeu::doit_jouer() (vous devez jouer à partir de ce moment)
   5. ClientJeu::requete_acceptee() (ou ClientJeu::requete_refusee()
   et retour à 4.)
   6. ClientJeu::jeu_change() (vous perdez la carte jouée)
   7. ClientJeu::carte_jouee() (par vous)
   8. ClientJeu::maitre_change() (éventuellement, dans ce cas c'est
   vous)
   9. ClientJeu::tapis_change()

   Fin de levée :
   1. ClientJeu::carte_jouee() (par le dernier joueur)
   2. ClientJeu::maitre_change() (éventuellement)
   3. 5 fois (dans l'ordre des cartes jouées)
   ClientJeu::carte_gagnee()
   4. ClientJeu::tapis_change()
   5. ClientJeu::doit_jouer() (si vous avez remporté le pli)

   Fin de partie : comme à la fin de la dernière levée, sans le
   dernier point. À la place, on a ClientJeu::partie_terminee()

   @section conclusion Conclusion
   Il y a un protocole à respecter pour communiquer avec le serveur,
   et pour utiliser les classes existantes, il faut se mettre au bon
   endroit, compiler les bons fichiers, utilier la dépendance netork,
   de déclarer une variable de type ClientJeu.
*/
