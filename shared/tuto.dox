/**
   @page tutoriel Tutoriel : utilisation, contribution

   @section zero À partir de zéro

   Vous voulez développer votre propre client (ou votre propre
   serveur). Vous devez vous connecter en tcp sur le serveur (45678,
   port par défaut). Des messages seront échangés avec lui. Un message
   contient :

   1. Sa taille, sur 1 octet non signé.
   2. Son type, sur 1 octet non signé.
   3. Sa partie variable.
   
   Voici les types :

   - 0  : erreur_protocole. Pas de partie variable. Signification :
   vous avez dit quelque chose à un moment inopportun, ou ça n'entre
   pas dans le protocole.

   - 1  : refuse. Pas de partie variable. Signification : vous avez
   fait une requête du bon type au bon moment, mais elle ne respecte
   pas les règles.

   - 2  : numero. Morceau variable : mon numéro sur 1 octet non
   signé. Votre numéro est un nombre entre 0 et 4 inclus. Si c'est 0,
   vous devez être le premier à priser. Si c'est x, il faut attendre
   de recevoir x messages de type contrat avant de priser.

   - 3  : distribution. Morceau variable : mes 15 cartes, chacune sur 1
   octet non signé. 

   - 4  : prise. Morceau variable : ma prise (1 octet, non signé). 0 :
   passe, 4 : garde contre. Le client doit émettre ce message. 

   - 5  : contrat. Morceau variable : la prise du joueur (1 octet, non
   signé). Un contrat intermédiaire a été formulé.

   - 6  : appel. Pas de partie variable. Vous avez remporté les
   enchères, et vous devez maintenant appeler une carte.

   - 7  : appeler. Morceau variable : la carte que vous voulez appeler
   (1 octet, non signé).

   - 8  : contrat_final. Morceau variable : 1 octet non signé
   (preneur), 1 octet non signé (prise), 1 octet non signé (carte
   appelée). 

   - 9  : chien. Morceau variable : 3 octets (les 3 cartes dévoilées du
   chien). Si vous êtes le preneur, vous devez écarter.

   - 10 : ecart. Morceau variable : 3 octets (les 3 cartes que vous
   voudriez écarter).

   - 11 : atout. Morceau variable : au plus 3 octets (les atouts
   écartés). 

   - 12 : inutilisé

   - 13 : jeu. Morceau variable : 1 octet (5), le joueur ayant demandé
   un chelem ou 5. Donc 5.

   - 14 : inutilisé

   - 15 : inutilisé

   - 16 : requete. Morceau variable : 1 octet (la carte que vous
   voudriez jouer). C'est à vous s'il y a eu (votre tour - tour du
   joueur d'ouverture) modulo 5 cartes jouées depuis le dernier pli.

   - 17 : carte. Morceau variable : 1 octet (la carte jouée). À vous de
   déterminer qui l'a jouée, à partir du numéro du joueur d'ouverture
   et le nombre de cartes jouées depuis la fin du dernier pli.

   - 18 : pli. Morceau variable : 1 octet (numéro du joueur
   d'ouverture). 

   - 19 : resultat. La partie est finie. Morceau variable : 5 mots de 2
   octets, signés (les résultats de chacun).
   .

   Vous devez donc émettre : prise, appeler, ecarter, requete,
   requete, ... dans le cas où vous prenez (prise autre que garde
   contre ou garde sans) en tant que client.
   
   @section un En utilisant ce qu'on a déjà
   
   L'objectif est d'utiliser la classe ClientJeu, qui fournit de
   l'information sous forme de signaux Qt, et qui permet d'enregistrer
   des ordres facilement. Vous avez droit à tous les signaux de
   ClientJeu, plus ClientJeu::partie qui vous fournit une
   PartieClient, d'où vous pourrez savoir le Partie::tour(), 
   Partie::attaquant(), PartieClient::mon_jeu(), Partie::tapis(),
   ... 
   
   En ce qui concerne les ordres à envoyer, vous pouvez utiliser
   ClientJeu::formuler_prise, ClientJeu::formuler_appel,
   ClientJeu::formuler_ecart, ClientJeu::formuler_requete.

   Étape par étape :
   
   Commencez par récupérer les sources, puis déplacez-vous dans
   client/. Faites un dossier, par exemple ai, puis
   déplacez-vous dedans et faites un nouveau projet Qt. Le fichier de
   projet doit ressembler au fichier ci-dessous : on ajoute la dépendance 
   network, et on inclue et compile tous les fichiers de ../shared et
   ../../shared. 
   
   @include ../client/ai/ia.pro

   Maintenant, on peut travailler. Faites un fichier principal (ici,
   main_program.cpp), ici :

   @include ../client/ai/main_program.cpp

   On voit que l'on a fait une classe externe, IA. Il suffit après de
   connecter les signaux d'information de ClientJeu aux slots de notre
   nouvelle classe. Ensuite, il faut appeler les slots
   ClientJeu::formuler_* pour interagir avec le serveur. Dans
   l'exemple, j'ai fait une IA dite "basique" :

   @include ../client/ai/ia.hpp
   
   @include ../client/ai/ia.cpp

   @section conclusion Conclusion
   Il y a un protocole à respecter pour communiquer avec le serveur,
   et pour utiliser les classes existantes, il faut se mettre au bon
   endroit, compiler les bons fichiers, utilier la dépendance netork,
   de déclarer une variable de type ClientJeu.
*/
